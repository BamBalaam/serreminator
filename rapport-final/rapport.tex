\documentclass[a4paper,10pt]{report}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[left=2.5cm,top=2cm,right=2.5cm,nohead,nofoot]{geometry}
\usepackage{url}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{afterpage}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{csquotes}
\usepackage{fullpage}

\usepackage[pdftex,
            pdfauthor={A. Caccia, A. Madeira Cortes, N. Marchant, R. Fontaine},
            pdftitle={Contrôle automatique d'une serre},
            pdfsubject={Contrôle automatique d'une serre}]{hyperref}

\linespread{1.1}

\setlength{\parskip}{0.5em}

\begin{document}

\begin{titlepage}
    \begin{center}
        \textbf{\textsc{Université Libre de Bruxelles}}\\
        \textbf{\textsc{Faculté des Sciences}}\\
        \textbf{\textsc{Département d'Informatique}}

        \vfill{}
        \vfill{}

        \begin{center}
            {\Huge Contrôle automatique d'une serre}
        \end{center}

        {\Huge \par}

        \begin{center}
            {\large A. Caccia, A. Madeira Cortes, N. Marchant, R. Fontaine}
        \end{center}

        {\Huge \par}
        \vfill{}
        \vfill{}

        \begin{flushleft}
            {\large \textbf{Superviseurs :} M. Labbé, T. Lenaerts}
            \hfill{}
        \end{flushleft}

        {\large\par}
        \vfill{}
        \vfill{}
        % \enlargethispage{3cm} % do not remove

        \textbf{Année académique 2015--2016}
    \end{center}
\end{titlepage}

\begin{abstract}
Ce rapport présente ...
\end{abstract}


\tableofcontents


\chapter{Introduction}
1.Une introduction contexte + la description du méthodologie étudié,

2 pages

\chapter{Etat de l'art}
\section{Contrôle automatique}
\subsection{Bang bang control}
Le \emph{Bang bang control} aussi appelé \emph{On-Off control} ou en français "\emph{Tout ou rien}" est un contrôleur qui ne peut accepter que deux états de contrôle tels que ouvert ou fermé, ou allumé ou éteint.

Des exemples très classiques d'utilisation de ce type de contrôleur sont les thermostats: le chauffage s'allume sous une température minimale, et s'éteint au-dessus d'un seuil maximal.


\subsection{PID}
\subsubsection{Création et évolution au long du temps}

Le régulateur PID est un système de contrôle.
Il porte ce nom à cause de ses trois actions (action proportionnelle, intégrale et dérivée).

Les premières analyses techniques de PID datent de 1922, lorsque Nicolas Minorsky essaye de créer des systèmes de pilotage automatique pour la marine des États-Unis. \cite{minorsky1922directional}

Depuis son invention, la popularité de ce régulateur a fortement augmenté \cite{ang2005pid}.
PID et ses variantes sont les systèmes de contrôle les plus utilisés (95\% des régulateurs dans les procédés industriels) \cite{Kinnaert2013} \cite{Astrom2002}.

Malgré le fait que de nombreuses autres techniques ont été inventées depuis la création de PID, il maintient son fonctionnement de base et a simplement évolué avec le temps:
il existe à présent soit en tant que bloc fonctionnel dans des contrôleurs logiques programmables, soit en tant que contrôleur ``standalone''.

PID maintient sa popularité car il est souvent admis qu'aucun autre contrôleur n'égale la simplicité, le fonctionnement clair, la facilité d'application et d'utilisation offerte par PID.
Il sert aussi de composante fondamentale à d'autres contrôleurs plus complexes \cite{ang2005pid} \cite{visioli2006practical}.

\subsubsection{Rôle de PID}
Le rôle de PID est de calculer en continu une erreur.
Cette erreur est la différence entre une variable mesurée et un point de consigne arbitraire.
PID tente de minimiser l'erreur au long du temps en s'ajustant peu à peu.
Étant donné que PID se base uniquement sur des variables mesurées, sans connaissance du procédé sous-jacent, il a énormément d'applications différentes \cite{bennett1993history}.

Le grand avantage de PID est que l'on peut ajuster certains de ses paramètres pour s'adapter à la réalité du projet.
Les effets (positifs ou négatifs) de l'ajustement de ces paramètres sont, entre autres \cite{zhong2006pid} :
\begin{enumerate}
\item la stabilité,
\item la précision (l'erreur même quand l'équilibre est atteint),
\item la rapidité (le temps d'attente avant que le système n'arrive à la stabilité)
\end{enumerate}

Il est aussi possible dans quelques applications de PID que certaines actions soient inutiles.
Dans ce cas-là, on parle de contrôleurs PI, PD, P ou I.
Par exemple, une des raisons d'enlever l'action dérivée est qu'elle est fort sensible au bruit lors des mesures
(voir \ref{sec:alternatives-to-PID}).

\subsubsection{Les trois paramètres de PID}
L'utilisation de PID est décrite par la formule suivante\cite{visioli2006practical} :

$$u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{de}{dt}$$

Analysons les plusieurs parties de cette formule:

\begin{description}
\item[Action proportionnelle (P) :]
    Cette valeur est proportionnelle à l'erreur de contrôle courante ($K_p e(t)$ ).
\item[Action intégrale (I) :]
    Fait varier la réponse de PID en fonction des valeurs passées de l'erreur de contrôle ($K_i \int_{0}^{t} e(\tau) d\tau$).
\item[Action dérivée (D) :]
    Basée sur les valeurs futures estimées pour l'erreur de contrôle ($K_d \frac{de}{dt}$ ).
\end{description}


\subsection{P controller}
Le \emph{Proportional Control} est l'ancêtre du PID, il ne prend en compte que la partie proportionnelle de celui-ci.
Cet algorithme se situe entre l'algorithme Bang Bang et PID:
en effet, là où \emph{Bang Bang} va corriger l'état simplement en allumant ou en éteignant un appareil, l'algorithme P control va lui, appliquer une réponse appropriée à la perturbation.

Un tel contrôleur s'exprime par l'équation
\begin{equation}P_{out} = K_{P}e(t) + p0\end{equation}
dans laquelle $e(t) = SP - SV$ est l'erreur mesurée (différence entre valeur attendue et valeur reçue), $K_{P}$ est le paramètre de gain proportionnel, $P_{out}$ est la réponse à la perturbation et $p0$ est la correction à appliquer, nécessaire vu que cet algorithme n'a pas de composante intégrale par rapport à PID.

Un grand avantage de l'utilisation de ce type de contrôleur est qu'il n'y a qu'un seul paramètre à configurer, qui définit à quel point la correction sera agressive : plus le paramètre $K_{p}$ est petit, plus la réaction est lente, et à l'inverse, plus il est grand, plus ce sera rapide.

Si l'implémentation d'un tel contrôleur est aisée, ses sorties produisent un phénomène d'\emph{offset}, un décalage par rapport aux valeurs attendues.

Le choix d'un tel contrôleur par rapport à PID dépend de l'utilisation, de la précision et de la vitesse des corrections désirées.
Des exemples où l'algorithme P control est suffisant sont donnés dans \cite{sellers2001overview}.

\subsection{Integral controller}
Le principe d'un \emph{Integral controller} est de corriger un offset résultant de l'utilisation d'un P controller.
Un tel contrôleur est caractérisé dans \cite{svrcek2006real} par l'équation
\begin{equation}P_{out} = \frac{1}{T_{i}}\int e dt + MV_{0}\end{equation}
où $MV_{0}$ correspond à la correspond biaisée de P controller,
$\int e dt$ représente l'intégrale des erreurs sur l'intervalle de temps $dt$ et $T_{i}$ est le temps intégral défini comme le temps nécessaire pour changer la sortie du contrôleur d'une quantité égale à l'erreur.

Bien que ce contrôleur propose une correction aux décalages, on observe un temps de réponse jusqu'à dix fois inférieur à l'utilisation d'un P controller seul (\cite{svrcek2006real}).

\subsection{PI controller}
Un contrôleur PI utilise à la fois l'action proportionnelle et l'action intégrale.
Ils sont caractérisés par l'équation
\begin{equation}P_{out} = K_{P} e + K_{I} \int e dt\end{equation}
où $K_{p}$ et $K_{I}$ sont les paramètres de réglages proportionnel et intégral
et les autres symboles correspondent à ce qui est indiqué dans les sections \emph{P controller} et \emph{Integral controller}.

Ces contrôleurs sont 50\% plus lents qu'un contrôleur P seul, mais plus rapides que l'ajout d'un contrôleur intégral \cite{svrcek2006real}.
En effet, si l'on compare son équation avec celle du P controller, le terme $p0$ a été remplacé par une correction intégrale, ce qui corrige l'erreur automatiquement.

\subsection{MPC controller}
\emph{MPC} est un contrôleur permettant la prédiction des futurs états de différentes variables dans un système.
Celui-ci utilise des stratégies prédictives afin de calculer les prochaines valeurs de sorties possibles.

Contrairement à PID, MPC peut gérer plusieurs variables, est facile à configurer et peut gérer des changements dans la structure du circuit.
Par contre, de nombreux modèles MPC ne supportent que les circuits en boucle ouverte.
De plus, ils nécessitent un grand nombre de modèles pour interpoler la réponse et si la commande prédictive est erronée, les performances vont être faibles même si les modèles sont corrects.

Une comparaison entre APM (une variante simple de MPC) et PID a été faite dans \cite{saletovic2014apm}, et montre qu'avec des configurations optimales, APM a apporté un meilleur contrôle que PID.

\section{Détermination des paramètres de PID}


Pour déterminer les valeurs optimales des paramètres de PID, plusieurs algorithmes peuvent être utilisés. Nous en présenterons 3 : la méthode manuelle, la méthode de Ziegler–Nichols et celle de Tyreus Luyben.

\subsection{La méthode manuelle}
Cette technique s'applique sur un système en fonctionnement.
L'avantage de cette technique, c'est qu'elle ne nécessite aucun calcul mathématique complexe.
Cependant, elle nécessite l'interaction d'un technicien expérimenté.

L'algorithme se déroule en 4 étapes:
\begin{enumerate}
    \item Les valeurs des 3 paramètres sont fixées à $0$.
    \item Le paramètre $K_p$ est incrémenté jusqu'à ce que la sortie du système se mette à osciller.
    On prendra comme valeur pour $K_p$ la moitié de celle obtenue précédemment.
    \item $K_i$ est augmenté jusqu'au moment où l'offset est corrigé dans un temps acceptable pour le système.
    \item Si nécessaire, $K_d$ est augmenté jusqu'au moment où la boucle est suffisamment rapide pour atteindre à nouveau la consigne après une perturbation extérieure.
\end{enumerate}

\subsection{Ziegler–Nichols}
% ziegler1942optimum
% silva2007pid
% http://www.chem.mtu.edu/~tbco/cm416/tuning_methods.pdf
Comme la méthode manuelle, Ziegler–Nichols s'applique aussi sur un système en fonctionnement. Cependant, elle utilise des calculs un peu plus complexes que la méthode manuelle mais son avantage est qu'elle nécessite des techniciens moins expérimentés.\cite{ziegler1942optimum}\cite{silva2007pid}

Elle débute comme la méthode manuelle :
\begin{enumerate}
    \item Les valeurs des 3 paramètres sont fixées à $0$.
    \item $K_p$ est augmenté jusqu'à ce que la sortie de la boucle oscille (comme précédemment).
\end{enumerate}

Par contre, cette fois-ci, on va nommer la valeur de $K_p$ ainsi obtenue $K_u$ et la période de l'oscillation $P_u$.
Ensuite, les autres paramètres sont déterminés à l'aide du tableau \ref{tab:ZieglerNicholsTuningFormulas}

\def\tabularxcolumn#1{m{#1}}
\begin{figure}[ht]
    \begin{center}
        \begin{tabularx}{\textwidth}{| c | X | X | X |}
            \hline
            & $K_p$ & $K_i$ & $K_d$\\ \hline
            P & \begin{equation*}\frac{K_u}{2}\end{equation*} & &\\ \hline
            PI & \begin{equation*}\frac{K_u}{2,2}\end{equation*} & \begin{equation*}1,2 \cdot \frac{K_p}{P_u}\end{equation*} &\\ \hline
            PID & \begin{equation*}\frac{K_u}{1,7}\end{equation*} & \begin{equation*}2 \cdot \frac{K_p}{P_u}\end{equation*} & \begin{equation*}K_p \cdot \frac{P_u}{8}\end{equation*} \\
            \hline
        \end{tabularx}
    \end{center}
    \caption{Tableau des formules pour Ziegler–Nichols}
    \label{tab:ZieglerNicholsTuningFormulas}
\end{figure}

\subsection{Tyreus Luyben}
%http://www.chem.mtu.edu/~tbco/cm416/tuning_methods.pdf
Cette méthode est fort similaire a celle de Ziegler-Nichols. La plus grande différence est la formule utilisée.\cite{shahrokhi2013comparison}

\def\tabularxcolumn#1{m{#1}}
\begin{figure}[ht]
    \begin{center}
        \begin{tabularx}{\textwidth}{| c | X | X | X |}
            \hline
            & $K_p$ & $K_i$ & $K_d$\\ \hline
            PI & \begin{equation*}\frac{K_u}{3,2}\end{equation*} & \begin{equation*}\frac{K_p}{2,2 \cdot P_u}\end{equation*} &\\ \hline
            PID & \begin{equation*}\frac{K_u}{2,2}\end{equation*} & \begin{equation*}\frac{K_p}{2,2 \cdot P_u}\end{equation*} & \begin{equation*}K_p \cdot \frac{P_u}{6,3}\end{equation*} \\
            \hline
        \end{tabularx}
    \end{center}
    \caption{Tableau des formules pour Ziegler–Nichols}
    \label{tab:ZieglerNicholsTuningFormulas}
\end{figure}

\subsection{Genetic}

\subsection{Tabu}

\chapter{Méthodes implémentées}
3.un rapport sur les méthodes investiguées et leurs fonctionnement

\section{Contrôle automatique}
BangBang
PID

\section{Détermination des paramètres de PID}

Ziegler + alternatives
Genetic
Tabu
Manuel

\chapter{Résultats expérimentaux}
4.les résultats expérimentaux, + un comparaison avec des approches existant.

\section{Méthode expérimentale}
Déterminer des métriques
    Temps de montée
    ampiltude max
    integrale de l'erreur

\section{Résultats}
Résulatas pour chaque méthode

pour genetic : comparer en fct du nombre de générations (et le de taille de la pop)

\chapter{Discussion}
5.l’explication/discussion de ces résultats

\chapter{Conclusion et perspectives}
6.conclusions et perspectives.

\bibliographystyle{apalike}

\bibliography{biblio}
\addcontentsline{toc}{chapter}{Bibliographie}

\end{document}
